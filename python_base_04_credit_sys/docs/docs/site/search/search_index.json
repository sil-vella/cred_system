{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Credit System - Python Backend","text":"<p>Welcome to the automated documentation for the Credit System Python backend.</p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>This documentation is automatically generated from your codebase using:</p> <ul> <li>AI-powered docstrings using Cursor-style patterns</li> <li>Automatic codebase discovery and indexing</li> <li>Dynamic content generation from actual code structure</li> <li>Live updates with code changes</li> </ul>"},{"location":"#codebase-overview","title":"\ud83d\udcca Codebase Overview","text":"<ul> <li>\ud83d\udcc1 Files: 26</li> <li>\ud83c\udfd7\ufe0f Classes: 15</li> <li>\u2699\ufe0f Functions: 4</li> <li>\ud83d\udce6 Modules: 26</li> </ul>"},{"location":"#features","title":"\ud83d\udd0d Features","text":"<ul> <li>\ud83d\udd0d Auto-generated API Reference: All classes and functions are documented</li> <li>\ud83d\udd04 Live Updates: Documentation updates automatically with code changes</li> <li>\ud83d\udd0e Search: Full-text search across all documentation</li> <li>\ud83c\udf19 Dark Mode: Toggle between light and dark themes</li> <li>\ud83d\udcf1 Mobile-Friendly: Responsive design for all devices</li> </ul>"},{"location":"#navigation","title":"\ud83d\udcda Navigation","text":"<ul> <li>\ud83d\udcd6 API Reference: Detailed documentation of all code components</li> <li>\ud83c\udfd7\ufe0f Architecture: System design and data flow documentation</li> <li>\ud83d\udee0\ufe0f Development: Setup, testing, and deployment guides</li> </ul>"},{"location":"#recent-updates","title":"\ud83c\udfaf Recent Updates","text":"<p>Last updated: 2025-07-15 18:20:44</p> <p>This documentation is automatically maintained and updated with every code change.</p>"},{"location":"api/overview/","title":"API Overview","text":"<p>Complete API documentation for the Credit System.</p>"},{"location":"architecture/auth/","title":"Authentication &amp; Authorization","text":"<p>Authentication and authorization flow in the Credit System.</p>"},{"location":"architecture/auth/#components","title":"Components","text":""},{"location":"architecture/auth/#jwt-manager","title":"JWT Manager","text":"<p>Handles JWT token generation, validation, and refresh.</p>"},{"location":"architecture/auth/#api-key-manager","title":"API Key Manager","text":"<p>Manages API key authentication and rate limiting.</p>"},{"location":"architecture/auth/#encryption-manager","title":"Encryption Manager","text":"<p>Handles data encryption and security operations.</p>"},{"location":"architecture/auth/#vault-manager","title":"Vault Manager","text":"<p>Manages secrets and sensitive configuration.</p>"},{"location":"architecture/data-flow/","title":"Data Flow","text":"<p>How data flows through the Credit System application.</p>"},{"location":"architecture/data-flow/#request-flow","title":"Request Flow","text":"<ol> <li>API Request \u2192 Rate Limiter</li> <li>Authentication \u2192 JWT Manager</li> <li>Authorization \u2192 API Key Manager</li> <li>Business Logic \u2192 Module Manager</li> <li>Data Access \u2192 Database Manager</li> <li>Caching \u2192 Redis Manager</li> <li>Response \u2192 Client</li> </ol>"},{"location":"architecture/data-flow/#dependencies","title":"Dependencies","text":""},{"location":"architecture/data-flow/#app","title":"app","text":"<ul> <li><code>sys</code></li> <li><code>flask.Flask</code></li> <li><code>flask_cors.CORS</code></li> <li><code>utils.config.config.Config</code></li> <li><code>core.managers.app_manager.AppManager</code></li> <li><code>tools.logger.custom_logging.custom_log</code></li> <li><code>importlib</code></li> <li><code>core.metrics.init_metrics</code></li> <li><code>os</code></li> </ul>"},{"location":"architecture/data-flow/#none","title":"None","text":"<ul> <li><code>hooks_manager.HooksManager</code></li> <li><code>communications_main.CommunicationsModule</code></li> <li><code>flask.Flask</code></li> <li><code>datetime.datetime</code></li> <li><code>prometheus_flask_exporter.PrometheusMetrics</code></li> <li><code>core.managers.redis_manager.RedisManager</code></li> <li><code>config.config.Config</code></li> <li><code>cryptography.fernet.Fernet</code></li> <li><code>cs_user_management_main.CSUserManagementModule</code></li> <li><code>typing.Any</code></li> <li><code>tools.logger.custom_logging.log_function_call</code></li> <li><code>database_manager.DatabaseManager</code></li> <li><code>service_manager.ServicesManager</code></li> <li><code>logging</code></li> <li><code>base64</code></li> <li><code>prometheus_client.Histogram</code></li> <li><code>requests</code></li> <li><code>vault_manager.VaultManager</code></li> <li><code>typing.Union</code></li> <li><code>redis_manager.RedisManager</code></li> <li><code>jwt_manager.JWTManager</code></li> <li><code>os</code></li> <li><code>typing.Optional</code></li> <li><code>tools.logger.custom_logging.function_log</code></li> <li><code>rate_limiter_manager.RateLimiterManager</code></li> <li><code>sys</code></li> <li><code>json</code></li> <li><code>traceback</code></li> <li><code>flask_cors.CORS</code></li> <li><code>enum.Enum</code></li> <li><code>gzip</code></li> <li><code>cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC</code></li> <li><code>core.managers.app_manager.AppManager</code></li> <li><code>abc.abstractmethod</code></li> <li><code>typing.Dict</code></li> <li><code>psycopg2</code></li> <li><code>importlib</code></li> <li><code>re</code></li> <li><code>custom_logging.sanitize_log_message</code></li> <li><code>typing.List</code></li> <li><code>typing.Callable</code></li> <li><code>module_manager.ModuleManager</code></li> <li><code>transactions_main.TransactionsModule</code></li> <li><code>app_manager.AppManager</code></li> <li><code>datetime.timedelta</code></li> <li><code>glob</code></li> <li><code>core.managers.database_manager.DatabaseManager</code></li> <li><code>error_handler.ErrorHandler</code></li> <li><code>utils.config.config.Config</code></li> <li><code>custom_logging.custom_log</code></li> <li><code>prometheus_client.Counter</code></li> <li><code>exceptions.validation_exceptions.ValidationError</code></li> <li><code>html</code></li> <li><code>cryptography.hazmat.primitives.hashes</code></li> <li><code>encryption_manager.EncryptionManager</code></li> <li><code>abc.ABC</code></li> <li><code>tools.logger.custom_logging.game_play_log</code></li> <li><code>tools.logger.custom_logging.custom_log</code></li> <li><code>wallet_main.WalletModule</code></li> <li><code>prometheus_client.Gauge</code></li> <li><code>core.metrics.init_metrics</code></li> </ul>"},{"location":"architecture/data-flow/#toolsloggeraudit_logger","title":"tools.logger.audit_logger","text":"<ul> <li><code>typing.Optional</code></li> <li><code>glob</code></li> <li><code>json</code></li> <li><code>datetime.datetime</code></li> <li><code>gzip</code></li> <li><code>custom_logging.custom_log</code></li> <li><code>typing.Any</code></li> <li><code>typing.Dict</code></li> <li><code>custom_logging.sanitize_log_message</code></li> <li><code>os</code></li> </ul>"},{"location":"architecture/data-flow/#toolserror_handlingerror_handler","title":"tools.error_handling.error_handler","text":"<ul> <li><code>typing.Optional</code></li> <li><code>traceback</code></li> <li><code>datetime.datetime</code></li> <li><code>typing.Any</code></li> <li><code>tools.logger.custom_logging.custom_log</code></li> <li><code>typing.Dict</code></li> <li><code>psycopg2</code></li> <li><code>re</code></li> <li><code>logging</code></li> </ul>"},{"location":"architecture/data-flow/#coremetrics","title":"core.metrics","text":"<ul> <li><code>prometheus_client.Histogram</code></li> <li><code>flask.Flask</code></li> <li><code>prometheus_client.Counter</code></li> <li><code>utils.config.config.Config</code></li> <li><code>prometheus_flask_exporter.PrometheusMetrics</code></li> <li><code>prometheus_client.Gauge</code></li> </ul>"},{"location":"architecture/data-flow/#coremanagershooks_manager","title":"core.managers.hooks_manager","text":"<ul> <li><code>tools.logger.custom_logging.function_log</code></li> <li><code>tools.logger.custom_logging.custom_log</code></li> <li><code>tools.logger.custom_logging.game_play_log</code></li> <li><code>tools.logger.custom_logging.log_function_call</code></li> </ul>"},{"location":"architecture/data-flow/#coremanagersstate_manager","title":"core.managers.state_manager","text":"<ul> <li><code>typing.Optional</code></li> <li><code>core.managers.database_manager.DatabaseManager</code></li> <li><code>enum.Enum</code></li> <li><code>datetime.datetime</code></li> <li><code>core.managers.redis_manager.RedisManager</code></li> <li><code>typing.Any</code></li> <li><code>tools.logger.custom_logging.custom_log</code></li> <li><code>typing.Dict</code></li> <li><code>typing.List</code></li> <li><code>typing.Callable</code></li> <li><code>logging</code></li> </ul>"},{"location":"architecture/data-flow/#coremanagersvault_manager","title":"core.managers.vault_manager","text":"<ul> <li><code>typing.Optional</code></li> <li><code>datetime.timedelta</code></li> <li><code>json</code></li> <li><code>requests</code></li> <li><code>datetime.datetime</code></li> <li><code>os</code></li> <li><code>typing.Any</code></li> <li><code>typing.Dict</code></li> <li><code>logging</code></li> </ul>"},{"location":"architecture/data-flow/#coremanagerssecret_manager","title":"core.managers.secret_manager","text":"<ul> <li><code>os</code></li> </ul>"},{"location":"architecture/data-flow/#coremanagersencryption_manager","title":"core.managers.encryption_manager","text":"<ul> <li><code>base64</code></li> <li><code>typing.Optional</code></li> <li><code>cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC</code></li> <li><code>utils.config.config.Config</code></li> <li><code>cryptography.hazmat.primitives.hashes</code></li> <li><code>cryptography.fernet.Fernet</code></li> <li><code>typing.Any</code></li> <li><code>typing.Dict</code></li> <li><code>os</code></li> </ul>"},{"location":"architecture/data-flow/#coremodulesbase_module","title":"core.modules.base_module","text":"<ul> <li><code>typing.Optional</code></li> <li><code>abc.ABC</code></li> <li><code>typing.Any</code></li> <li><code>tools.logger.custom_logging.custom_log</code></li> <li><code>abc.abstractmethod</code></li> <li><code>typing.Dict</code></li> <li><code>typing.List</code></li> <li><code>logging</code></li> </ul>"},{"location":"architecture/data-flow/#utilsvalidationpayload_validator","title":"utils.validation.payload_validator","text":"<ul> <li><code>json</code></li> <li><code>typing.Union</code></li> <li><code>exceptions.validation_exceptions.ValidationError</code></li> <li><code>config.config.Config</code></li> <li><code>typing.Any</code></li> <li><code>typing.Dict</code></li> <li><code>typing.List</code></li> </ul>"},{"location":"architecture/data-flow/#utilsvalidationsanitizer","title":"utils.validation.sanitizer","text":"<ul> <li><code>typing.Union</code></li> <li><code>exceptions.validation_exceptions.ValidationError</code></li> <li><code>html</code></li> <li><code>config.config.Config</code></li> <li><code>typing.Any</code></li> <li><code>typing.Dict</code></li> <li><code>re</code></li> <li><code>typing.List</code></li> </ul>"},{"location":"architecture/overview/","title":"System Overview","text":"<p>High-level architecture of the Credit System Python backend.</p>"},{"location":"architecture/overview/#codebase-statistics","title":"Codebase Statistics","text":"<ul> <li>Total Files: 26</li> <li>Total Classes: 15</li> <li>Total Functions: 4</li> <li>Total Modules: 26</li> </ul>"},{"location":"architecture/overview/#module-structure","title":"Module Structure","text":"<ul> <li><code>app</code></li> <li><code>tools.logger.audit_logger</code></li> <li><code>tools.error_handling.error_handler</code></li> <li><code>core.metrics</code></li> <li><code>core.managers.hooks_manager</code></li> <li><code>core.managers.state_manager</code></li> <li><code>core.managers.vault_manager</code></li> <li><code>core.managers.secret_manager</code></li> <li><code>core.managers.encryption_manager</code></li> <li><code>core.modules.base_module</code></li> <li><code>utils.exceptions.validation_exceptions</code></li> <li><code>utils.validation.payload_validator</code></li> <li><code>utils.validation.sanitizer</code></li> </ul>"},{"location":"architecture/overview/#architecture-layers","title":"Architecture Layers","text":"<ol> <li>Managers Layer - Core application managers</li> <li>Modules Layer - Business logic modules</li> <li>Services Layer - External service interactions</li> <li>Utils Layer - Common utilities and tools</li> </ol>"},{"location":"development/deployment/","title":"Deployment","text":"<p>Deployment procedures and guidelines.</p>"},{"location":"development/deployment/#docker-deployment","title":"Docker Deployment","text":"<pre><code>docker build -t credit-system .\ndocker run -p 8000:8000 credit-system\n</code></pre>"},{"location":"development/setup/","title":"Development Setup","text":"<p>How to set up the development environment.</p>"},{"location":"development/setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Redis</li> <li>MongoDB</li> <li>Vault (optional)</li> </ul>"},{"location":"development/setup/#installation","title":"Installation","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"development/testing/","title":"Testing","text":"<p>Testing guidelines and procedures.</p>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":"<pre><code>python -m pytest tests/\n</code></pre>"},{"location":"reference/managers/","title":"Managers","text":"<p>Core managers that handle different aspects of the application.</p>"},{"location":"reference/managers/#hooksmanager","title":"HooksManager","text":"<p>File: <code>core/managers/hooks_manager.py</code></p> <p>Type: class</p> <p>Methods: - <code>__init__()</code> - <code>register_hook()</code> - <code>register_hook_callback()</code> - <code>trigger_hook()</code> - <code>clear_hook()</code> - <code>dispose()</code></p> <p>Attributes: - <code>context_info</code> - <code>callback_name</code></p>"},{"location":"reference/managers/#core.managers.hooks_manager.HooksManager","title":"<code>core.managers.hooks_manager.HooksManager</code>","text":"<p>class HooksManager - Manages application state and operations</p> <p>Attributes:</p> Name Type Description <code>context_info</code> <p>TODO: Add description</p> <code>callback_name</code> <p>TODO: Add description</p> <p>Methods:</p> Name Description <code>__init__</code> <p>TODO: Add description</p> <code>register_hook</code> <p>TODO: Add description</p> <code>register_hook_callback</code> <p>TODO: Add description</p> <code>trigger_hook</code> <p>TODO: Add description</p> <code>clear_hook</code> <p>TODO: Add description</p> <code>dispose</code> <p>TODO: Add description</p> Source code in <code>core/managers/hooks_manager.py</code> <pre><code>class HooksManager:\n    \"\"\"\n    class HooksManager - Manages application state and operations\n\n    Attributes:\n        context_info: TODO: Add description\n        callback_name: TODO: Add description\n\n    Methods:\n        __init__(): TODO: Add description\n        register_hook(): TODO: Add description\n        register_hook_callback(): TODO: Add description\n        trigger_hook(): TODO: Add description\n        clear_hook(): TODO: Add description\n        dispose(): TODO: Add description\n\n    \"\"\"\n    def __init__(self):\n        # A dictionary to hold hooks and their callbacks with priorities and optional context\n        self.hooks = {\n            \"app_startup\": [],  # Predefined default hook\n        }\n        custom_log(\"HooksManager instance created.\")\n\n    @log_function_call\n    def register_hook(self, hook_name):\n        \"\"\"\n        Register a new hook with the given name.\n        :param hook_name: str - The name of the hook to register.\n        \"\"\"\n        if hook_name in self.hooks:\n            raise ValueError(f\"Hook '{hook_name}' is already registered.\")\n\n        self.hooks[hook_name] = []\n        custom_log(f\"Hook '{hook_name}' registered successfully.\")\n\n    @log_function_call\n    def register_hook_callback(self, hook_name, callback, priority=10, context=None):\n        \"\"\"\n        Register a callback function to a specific hook with a priority and optional context.\n        :param hook_name: str - The name of the hook.\n        :param callback: function - The callback function to register.\n        :param priority: int - The priority of the callback (lower number = higher priority).\n        :param context: str - The optional context (e.g., article type) for the callback.\n        \"\"\"\n        if hook_name not in self.hooks:\n            raise ValueError(f\"Hook '{hook_name}' is not registered.\")\n\n        # Add the callback to the hook\n        self.hooks[hook_name].append({\n            \"priority\": priority,\n            \"callback\": callback,\n            \"context\": context\n        })\n\n        # Sort callbacks by priority\n        self.hooks[hook_name].sort(key=lambda x: x[\"priority\"])\n\n        # Detailed logging of the callback registration\n        context_info = f\" (context: {context})\" if context else \"\"\n        callback_name = callback.__name__ if hasattr(callback, \"__name__\") else str(callback)\n        custom_log(f\"Callback '{callback_name}' registered to hook '{hook_name}' with priority {priority}{context_info}.\")\n\n    @log_function_call\n    def trigger_hook(self, hook_name, data=None, context=None):\n        \"\"\"\n        Trigger a specific hook, executing only callbacks matching the context.\n        :param hook_name: str - The name of the hook to trigger.\n        :param data: Any - Optional data to pass to the callbacks.\n        :param context: str - The context to filter callbacks (e.g., article type).\n        \"\"\"\n        if hook_name not in self.hooks:\n            custom_log(f\"Warning: Hook '{hook_name}' is not registered. Skipping trigger.\")\n            return\n\n        custom_log(f\"Triggering hook '{hook_name}' with context: {context} and data: {data}\")\n\n        for entry in self.hooks[hook_name]:\n            # Execute only callbacks matching the context or global callbacks (no context)\n            if context is None or entry[\"context\"] == context:\n                custom_log(f\"Executing callback for hook '{hook_name}' with priority {entry['priority']} (context: {entry['context']}).\")\n                entry[\"callback\"](data)\n\n    @log_function_call\n    def clear_hook(self, hook_name):\n        \"\"\"\n        Clear all callbacks registered to a specific hook.\n        :param hook_name: str - The name of the hook to clear.\n        \"\"\"\n        if hook_name in self.hooks:\n            self.hooks[hook_name] = []\n            custom_log(f\"Cleared all callbacks for hook '{hook_name}'.\")\n        else:\n            custom_log(f\"Warning: Hook '{hook_name}' is not registered. Nothing to clear.\")\n\n    @log_function_call\n    def dispose(self):\n        \"\"\"\n        Dispose of all hooks and their callbacks.\n        \"\"\"\n        self.hooks.clear()\n        custom_log(\"All hooks have been disposed of.\")\n</code></pre>"},{"location":"reference/managers/#core.managers.hooks_manager.HooksManager-functions","title":"Functions","text":""},{"location":"reference/managers/#core.managers.hooks_manager.HooksManager.register_hook","title":"<code>register_hook(hook_name)</code>","text":"<p>Register a new hook with the given name. :param hook_name: str - The name of the hook to register.</p> Source code in <code>core/managers/hooks_manager.py</code> <pre><code>@log_function_call\ndef register_hook(self, hook_name):\n    \"\"\"\n    Register a new hook with the given name.\n    :param hook_name: str - The name of the hook to register.\n    \"\"\"\n    if hook_name in self.hooks:\n        raise ValueError(f\"Hook '{hook_name}' is already registered.\")\n\n    self.hooks[hook_name] = []\n    custom_log(f\"Hook '{hook_name}' registered successfully.\")\n</code></pre>"},{"location":"reference/managers/#core.managers.hooks_manager.HooksManager.register_hook_callback","title":"<code>register_hook_callback(hook_name, callback, priority=10, context=None)</code>","text":"<p>Register a callback function to a specific hook with a priority and optional context. :param hook_name: str - The name of the hook. :param callback: function - The callback function to register. :param priority: int - The priority of the callback (lower number = higher priority). :param context: str - The optional context (e.g., article type) for the callback.</p> Source code in <code>core/managers/hooks_manager.py</code> <pre><code>@log_function_call\ndef register_hook_callback(self, hook_name, callback, priority=10, context=None):\n    \"\"\"\n    Register a callback function to a specific hook with a priority and optional context.\n    :param hook_name: str - The name of the hook.\n    :param callback: function - The callback function to register.\n    :param priority: int - The priority of the callback (lower number = higher priority).\n    :param context: str - The optional context (e.g., article type) for the callback.\n    \"\"\"\n    if hook_name not in self.hooks:\n        raise ValueError(f\"Hook '{hook_name}' is not registered.\")\n\n    # Add the callback to the hook\n    self.hooks[hook_name].append({\n        \"priority\": priority,\n        \"callback\": callback,\n        \"context\": context\n    })\n\n    # Sort callbacks by priority\n    self.hooks[hook_name].sort(key=lambda x: x[\"priority\"])\n\n    # Detailed logging of the callback registration\n    context_info = f\" (context: {context})\" if context else \"\"\n    callback_name = callback.__name__ if hasattr(callback, \"__name__\") else str(callback)\n    custom_log(f\"Callback '{callback_name}' registered to hook '{hook_name}' with priority {priority}{context_info}.\")\n</code></pre>"},{"location":"reference/managers/#core.managers.hooks_manager.HooksManager.trigger_hook","title":"<code>trigger_hook(hook_name, data=None, context=None)</code>","text":"<p>Trigger a specific hook, executing only callbacks matching the context. :param hook_name: str - The name of the hook to trigger. :param data: Any - Optional data to pass to the callbacks. :param context: str - The context to filter callbacks (e.g., article type).</p> Source code in <code>core/managers/hooks_manager.py</code> <pre><code>@log_function_call\ndef trigger_hook(self, hook_name, data=None, context=None):\n    \"\"\"\n    Trigger a specific hook, executing only callbacks matching the context.\n    :param hook_name: str - The name of the hook to trigger.\n    :param data: Any - Optional data to pass to the callbacks.\n    :param context: str - The context to filter callbacks (e.g., article type).\n    \"\"\"\n    if hook_name not in self.hooks:\n        custom_log(f\"Warning: Hook '{hook_name}' is not registered. Skipping trigger.\")\n        return\n\n    custom_log(f\"Triggering hook '{hook_name}' with context: {context} and data: {data}\")\n\n    for entry in self.hooks[hook_name]:\n        # Execute only callbacks matching the context or global callbacks (no context)\n        if context is None or entry[\"context\"] == context:\n            custom_log(f\"Executing callback for hook '{hook_name}' with priority {entry['priority']} (context: {entry['context']}).\")\n            entry[\"callback\"](data)\n</code></pre>"},{"location":"reference/managers/#core.managers.hooks_manager.HooksManager.clear_hook","title":"<code>clear_hook(hook_name)</code>","text":"<p>Clear all callbacks registered to a specific hook. :param hook_name: str - The name of the hook to clear.</p> Source code in <code>core/managers/hooks_manager.py</code> <pre><code>@log_function_call\ndef clear_hook(self, hook_name):\n    \"\"\"\n    Clear all callbacks registered to a specific hook.\n    :param hook_name: str - The name of the hook to clear.\n    \"\"\"\n    if hook_name in self.hooks:\n        self.hooks[hook_name] = []\n        custom_log(f\"Cleared all callbacks for hook '{hook_name}'.\")\n    else:\n        custom_log(f\"Warning: Hook '{hook_name}' is not registered. Nothing to clear.\")\n</code></pre>"},{"location":"reference/managers/#core.managers.hooks_manager.HooksManager.dispose","title":"<code>dispose()</code>","text":"<p>Dispose of all hooks and their callbacks.</p> Source code in <code>core/managers/hooks_manager.py</code> <pre><code>@log_function_call\ndef dispose(self):\n    \"\"\"\n    Dispose of all hooks and their callbacks.\n    \"\"\"\n    self.hooks.clear()\n    custom_log(\"All hooks have been disposed of.\")\n</code></pre>"},{"location":"reference/managers/#coremanagershooks_manager","title":"core.managers.hooks_manager","text":"<p>File: <code>core/managers/hooks_manager.py</code></p> <p>Type: module</p>"},{"location":"reference/managers/#statemanager","title":"StateManager","text":"<p>File: <code>core/managers/state_manager.py</code></p> <p>Type: class</p> <p>Methods: - <code>__new__()</code> - <code>__init__()</code> - <code>get_instance()</code> - <code>reset_instance()</code> - <code>register_state()</code> - <code>get_state()</code> - <code>update_state()</code> - <code>delete_state()</code> - <code>get_state_history()</code> - <code>register_callback()</code> - <code>get_states_by_type()</code> - <code>get_active_states()</code> - <code>_validate_transition()</code> - <code>_update_transition_rules()</code> - <code>_add_to_history()</code> - <code>_trigger_state_callbacks()</code> - <code>_store_state_in_redis()</code> - <code>_get_state_from_redis()</code> - <code>_remove_state_from_redis()</code> - <code>_store_state_in_database()</code> - <code>_get_state_from_database()</code> - <code>_mark_state_deleted_in_database()</code> - <code>health_check()</code></p> <p>Attributes: - <code>_instance</code> - <code>_initialized</code> - <code>allowed_transitions</code> - <code>history_entry</code> - <code>state_record</code> - <code>redis_state</code> - <code>db_state</code> - <code>current_state</code> - <code>updated_state</code> - <code>transition_type</code> - <code>history</code> - <code>states</code> - <code>active_states</code> - <code>total_states</code> - <code>history</code></p>"},{"location":"reference/managers/#core.managers.state_manager.StateManager","title":"<code>core.managers.state_manager.StateManager</code>","text":"<p>Core State Management System - Central orchestrator for all application states.</p> <p>This is a generic, business-logic-agnostic state management system that provides: - State storage and retrieval - State transitions with validation - State change notifications - State history tracking - State-based access control</p> <p>Singleton Pattern: Only one instance exists throughout the application lifecycle.</p> Source code in <code>core/managers/state_manager.py</code> <pre><code>class StateManager:\n    \"\"\"\n    Core State Management System - Central orchestrator for all application states.\n\n    This is a generic, business-logic-agnostic state management system that provides:\n    - State storage and retrieval\n    - State transitions with validation\n    - State change notifications\n    - State history tracking\n    - State-based access control\n\n    Singleton Pattern: Only one instance exists throughout the application lifecycle.\n    \"\"\"\n\n    _instance = None\n    _initialized = False\n\n    def __new__(cls, redis_manager: Optional[RedisManager] = None, \n                database_manager: Optional[DatabaseManager] = None):\n        \"\"\"Singleton pattern implementation - ensures only one instance exists.\"\"\"\n        if cls._instance is None:\n            cls._instance = super(StateManager, cls).__new__(cls)\n        return cls._instance\n\n    def __init__(self, redis_manager: Optional[RedisManager] = None, \n                 database_manager: Optional[DatabaseManager] = None):\n        \"\"\"Initialize the state manager with optional external managers (singleton).\"\"\"\n        # Prevent re-initialization if already initialized\n        if StateManager._initialized:\n            return\n\n        self.logger = logging.getLogger(__name__)\n\n        # Use provided managers or create new ones\n        self.redis_manager = redis_manager if redis_manager else RedisManager()\n        self.database_manager = database_manager if database_manager else DatabaseManager()\n\n        # State storage\n        self._states: Dict[str, Dict[str, Any]] = {}\n        self._state_history: Dict[str, List[Dict[str, Any]]] = {}\n        self._transition_rules: Dict[str, Dict[str, List[str]]] = {}\n        self._state_callbacks: Dict[str, List[Callable]] = {}\n\n        # Configuration\n        self.state_ttl = 3600  # 1 hour default TTL\n        self.history_limit = 100  # Max history entries per state\n        self.enable_notifications = True\n\n        # Mark as initialized\n        StateManager._initialized = True\n\n        custom_log(\"\u2705 StateManager singleton initialized\")\n\n    @classmethod\n    def get_instance(cls, redis_manager: Optional[RedisManager] = None, \n                    database_manager: Optional[DatabaseManager] = None) -&gt; 'StateManager':\n        \"\"\"\n        Get the singleton instance of StateManager.\n\n        Args:\n            redis_manager: Optional Redis manager instance\n            database_manager: Optional database manager instance\n\n        Returns:\n            StateManager: The singleton instance\n        \"\"\"\n        return cls(redis_manager, database_manager)\n\n    @classmethod\n    def reset_instance(cls):\n        \"\"\"Reset the singleton instance (useful for testing).\"\"\"\n        cls._instance = None\n        cls._initialized = False\n\n    def register_state(self, state_id: str, state_type: StateType, \n                      initial_data: Dict[str, Any], \n                      allowed_transitions: Optional[List[str]] = None) -&gt; bool:\n        \"\"\"\n        Register a new state in the system.\n\n        Args:\n            state_id: Unique identifier for the state\n            state_type: Type of state (system, user, session, etc.)\n            initial_data: Initial state data\n            allowed_transitions: List of allowed transition types\n\n        Returns:\n            bool: True if registration successful\n        \"\"\"\n        try:\n            if state_id in self._states:\n                self.logger.warning(f\"State {state_id} already exists, updating instead\")\n                return self.update_state(state_id, initial_data)\n\n            # Create state record\n            state_record = {\n                'id': state_id,\n                'type': state_type.value,\n                'data': initial_data,\n                'created_at': datetime.utcnow().isoformat(),\n                'updated_at': datetime.utcnow().isoformat(),\n                'version': 1,\n                'active': True\n            }\n\n            # Store in memory\n            self._states[state_id] = state_record\n\n            # Store in Redis for persistence\n            self._store_state_in_redis(state_id, state_record)\n\n            # Store in database for long-term persistence\n            self._store_state_in_database(state_id, state_record)\n\n            # Initialize history\n            self._state_history[state_id] = []\n            self._add_to_history(state_id, StateTransition.CREATE.value, initial_data)\n\n            # Set transition rules\n            if allowed_transitions:\n                self._transition_rules[state_id] = {\n                    'allowed': allowed_transitions,\n                    'current': StateTransition.CREATE.value\n                }\n\n            custom_log(f\"\u2705 State {state_id} registered successfully\")\n            return True\n\n        except Exception as e:\n            self.logger.error(f\"Failed to register state {state_id}: {e}\")\n            return False\n\n    def get_state(self, state_id: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieve a state by ID.\n\n        Args:\n            state_id: State identifier\n\n        Returns:\n            Dict containing state data or None if not found\n        \"\"\"\n        try:\n            # Try memory first\n            if state_id in self._states:\n                return self._states[state_id]\n\n            # Try Redis\n            redis_state = self._get_state_from_redis(state_id)\n            if redis_state:\n                self._states[state_id] = redis_state\n                return redis_state\n\n            # Try database\n            db_state = self._get_state_from_database(state_id)\n            if db_state:\n                self._states[state_id] = db_state\n                # Cache in Redis\n                self._store_state_in_redis(state_id, db_state)\n                return db_state\n\n            return None\n\n        except Exception as e:\n            self.logger.error(f\"Failed to get state {state_id}: {e}\")\n            return None\n\n    def update_state(self, state_id: str, new_data: Dict[str, Any], \n                    transition: Optional[StateTransition] = None) -&gt; bool:\n        \"\"\"\n        Update an existing state.\n\n        Args:\n            state_id: State identifier\n            new_data: New state data\n            transition: Optional transition type\n\n        Returns:\n            bool: True if update successful\n        \"\"\"\n        try:\n            current_state = self.get_state(state_id)\n            if not current_state:\n                self.logger.error(f\"State {state_id} not found for update\")\n                return False\n\n            # Validate transition if provided\n            if transition and not self._validate_transition(state_id, transition):\n                self.logger.error(f\"Invalid transition {transition.value} for state {state_id}\")\n                return False\n\n            # Update state data\n            updated_state = current_state.copy()\n            updated_state['data'].update(new_data)\n            updated_state['updated_at'] = datetime.utcnow().isoformat()\n            updated_state['version'] += 1\n\n            # Store updated state\n            self._states[state_id] = updated_state\n            self._store_state_in_redis(state_id, updated_state)\n            self._store_state_in_database(state_id, updated_state)\n\n            # Add to history\n            transition_type = transition.value if transition else StateTransition.UPDATE.value\n            self._add_to_history(state_id, transition_type, new_data)\n\n            # Update transition rules\n            if transition:\n                self._update_transition_rules(state_id, transition)\n\n            # Trigger callbacks\n            self._trigger_state_callbacks(state_id, transition_type, new_data)\n\n            custom_log(f\"\u2705 State {state_id} updated successfully\")\n            return True\n\n        except Exception as e:\n            self.logger.error(f\"Failed to update state {state_id}: {e}\")\n            return False\n\n    def delete_state(self, state_id: str) -&gt; bool:\n        \"\"\"\n        Delete a state from the system.\n\n        Args:\n            state_id: State identifier\n\n        Returns:\n            bool: True if deletion successful\n        \"\"\"\n        try:\n            if state_id not in self._states:\n                self.logger.warning(f\"State {state_id} not found for deletion\")\n                return False\n\n            # Add deletion to history before removing\n            self._add_to_history(state_id, StateTransition.DELETE.value, {})\n\n            # Remove from memory\n            del self._states[state_id]\n\n            # Remove from Redis\n            self._remove_state_from_redis(state_id)\n\n            # Mark as deleted in database (soft delete)\n            self._mark_state_deleted_in_database(state_id)\n\n            # Clean up related data\n            if state_id in self._state_history:\n                del self._state_history[state_id]\n            if state_id in self._transition_rules:\n                del self._transition_rules[state_id]\n            if state_id in self._state_callbacks:\n                del self._state_callbacks[state_id]\n\n            custom_log(f\"\u2705 State {state_id} deleted successfully\")\n            return True\n\n        except Exception as e:\n            self.logger.error(f\"Failed to delete state {state_id}: {e}\")\n            return False\n\n    def get_state_history(self, state_id: str, limit: Optional[int] = None) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get history of state changes.\n\n        Args:\n            state_id: State identifier\n            limit: Maximum number of history entries to return\n\n        Returns:\n            List of history entries\n        \"\"\"\n        try:\n            history = self._state_history.get(state_id, [])\n            if limit:\n                history = history[-limit:]\n            return history\n\n        except Exception as e:\n            self.logger.error(f\"Failed to get history for state {state_id}: {e}\")\n            return []\n\n    def register_callback(self, state_id: str, callback: Callable) -&gt; bool:\n        \"\"\"\n        Register a callback function to be called when state changes.\n\n        Args:\n            state_id: State identifier\n            callback: Function to call on state change\n\n        Returns:\n            bool: True if registration successful\n        \"\"\"\n        try:\n            if state_id not in self._state_callbacks:\n                self._state_callbacks[state_id] = []\n\n            self._state_callbacks[state_id].append(callback)\n            custom_log(f\"\u2705 Callback registered for state {state_id}\")\n            return True\n\n        except Exception as e:\n            self.logger.error(f\"Failed to register callback for state {state_id}: {e}\")\n            return False\n\n    def get_states_by_type(self, state_type: StateType) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get all states of a specific type.\n\n        Args:\n            state_type: Type of states to retrieve\n\n        Returns:\n            List of states of the specified type\n        \"\"\"\n        try:\n            states = []\n            for state_id, state_data in self._states.items():\n                if state_data.get('type') == state_type.value:\n                    states.append(state_data)\n            return states\n\n        except Exception as e:\n            self.logger.error(f\"Failed to get states by type {state_type.value}: {e}\")\n            return []\n\n    def get_active_states(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get all active states.\n\n        Returns:\n            List of active states\n        \"\"\"\n        try:\n            return [state for state in self._states.values() if state.get('active', True)]\n        except Exception as e:\n            self.logger.error(f\"Failed to get active states: {e}\")\n            return []\n\n    # Private helper methods\n\n    def _validate_transition(self, state_id: str, transition: StateTransition) -&gt; bool:\n        \"\"\"Validate if a transition is allowed for a state.\"\"\"\n        if state_id not in self._transition_rules:\n            return True  # No rules means all transitions allowed\n\n        allowed_transitions = self._transition_rules[state_id].get('allowed', [])\n        return transition.value in allowed_transitions\n\n    def _update_transition_rules(self, state_id: str, transition: StateTransition):\n        \"\"\"Update transition rules after a state change.\"\"\"\n        if state_id in self._transition_rules:\n            self._transition_rules[state_id]['current'] = transition.value\n\n    def _add_to_history(self, state_id: str, transition: str, data: Dict[str, Any]):\n        \"\"\"Add an entry to state history.\"\"\"\n        if state_id not in self._state_history:\n            self._state_history[state_id] = []\n\n        history_entry = {\n            'timestamp': datetime.utcnow().isoformat(),\n            'transition': transition,\n            'data': data,\n            'version': self._states.get(state_id, {}).get('version', 1)\n        }\n\n        self._state_history[state_id].append(history_entry)\n\n        # Limit history size\n        if len(self._state_history[state_id]) &gt; self.history_limit:\n            self._state_history[state_id] = self._state_history[state_id][-self.history_limit:]\n\n    def _trigger_state_callbacks(self, state_id: str, transition: str, data: Dict[str, Any]):\n        \"\"\"Trigger registered callbacks for state changes.\"\"\"\n        if not self.enable_notifications or state_id not in self._state_callbacks:\n            return\n\n        for callback in self._state_callbacks[state_id]:\n            try:\n                callback(state_id, transition, data)\n            except Exception as e:\n                self.logger.error(f\"Callback error for state {state_id}: {e}\")\n\n    def _store_state_in_redis(self, state_id: str, state_data: Dict[str, Any]):\n        \"\"\"Store state in Redis cache.\"\"\"\n        try:\n            self.redis_manager.set(f\"state:{state_id}\", state_data, expire=self.state_ttl)\n        except Exception as e:\n            self.logger.warning(f\"Failed to store state {state_id} in Redis: {e}\")\n\n    def _get_state_from_redis(self, state_id: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Retrieve state from Redis cache.\"\"\"\n        try:\n            return self.redis_manager.get(f\"state:{state_id}\")\n        except Exception as e:\n            self.logger.warning(f\"Failed to get state {state_id} from Redis: {e}\")\n            return None\n\n    def _remove_state_from_redis(self, state_id: str):\n        \"\"\"Remove state from Redis cache.\"\"\"\n        try:\n            self.redis_manager.delete(f\"state:{state_id}\")\n        except Exception as e:\n            self.logger.warning(f\"Failed to remove state {state_id} from Redis: {e}\")\n\n    def _store_state_in_database(self, state_id: str, state_data: Dict[str, Any]):\n        \"\"\"Store state in database for persistence.\"\"\"\n        try:\n            if self.database_manager.available:\n                self.database_manager.insert(\"states\", state_data)\n        except Exception as e:\n            self.logger.warning(f\"Failed to store state {state_id} in database: {e}\")\n\n    def _get_state_from_database(self, state_id: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Retrieve state from database.\"\"\"\n        try:\n            if self.database_manager.available:\n                return self.database_manager.find_one(\"states\", {\"id\": state_id})\n        except Exception as e:\n            self.logger.warning(f\"Failed to get state {state_id} from database: {e}\")\n        return None\n\n    def _mark_state_deleted_in_database(self, state_id: str):\n        \"\"\"Mark state as deleted in database (soft delete).\"\"\"\n        try:\n            if self.database_manager.available:\n                self.database_manager.update(\n                    \"states\", \n                    {\"id\": state_id}, \n                    {\"active\": False, \"deleted_at\": datetime.utcnow().isoformat()}\n                )\n        except Exception as e:\n            self.logger.warning(f\"Failed to mark state {state_id} as deleted in database: {e}\")\n\n    def health_check(self) -&gt; Dict[str, Any]:\n        \"\"\"Perform health check on the state manager.\"\"\"\n        try:\n            active_states = len(self.get_active_states())\n            total_states = len(self._states)\n\n            return {\n                'status': 'healthy',\n                'active_states': active_states,\n                'total_states': total_states,\n                'redis_available': self.redis_manager.ping() if hasattr(self.redis_manager, 'ping') else True,\n                'database_available': self.database_manager.available if hasattr(self.database_manager, 'available') else True\n            }\n        except Exception as e:\n            return {\n                'status': 'unhealthy',\n                'error': str(e)\n            } \n</code></pre>"},{"location":"reference/managers/#core.managers.state_manager.StateManager-functions","title":"Functions","text":""},{"location":"reference/managers/#core.managers.state_manager.StateManager.__new__","title":"<code>__new__(redis_manager: Optional[RedisManager] = None, database_manager: Optional[DatabaseManager] = None)</code>","text":"<p>Singleton pattern implementation - ensures only one instance exists.</p> Source code in <code>core/managers/state_manager.py</code> <pre><code>def __new__(cls, redis_manager: Optional[RedisManager] = None, \n            database_manager: Optional[DatabaseManager] = None):\n    \"\"\"Singleton pattern implementation - ensures only one instance exists.\"\"\"\n    if cls._instance is None:\n        cls._instance = super(StateManager, cls).__new__(cls)\n    return cls._instance\n</code></pre>"},{"location":"reference/managers/#core.managers.state_manager.StateManager.__init__","title":"<code>__init__(redis_manager: Optional[RedisManager] = None, database_manager: Optional[DatabaseManager] = None)</code>","text":"Source code in <code>core/managers/state_manager.py</code> <pre><code>def __init__(self, redis_manager: Optional[RedisManager] = None, \n             database_manager: Optional[DatabaseManager] = None):\n    \"\"\"Initialize the state manager with optional external managers (singleton).\"\"\"\n    # Prevent re-initialization if already initialized\n    if StateManager._initialized:\n        return\n\n    self.logger = logging.getLogger(__name__)\n\n    # Use provided managers or create new ones\n    self.redis_manager = redis_manager if redis_manager else RedisManager()\n    self.database_manager = database_manager if database_manager else DatabaseManager()\n\n    # State storage\n    self._states: Dict[str, Dict[str, Any]] = {}\n    self._state_history: Dict[str, List[Dict[str, Any]]] = {}\n    self._transition_rules: Dict[str, Dict[str, List[str]]] = {}\n    self._state_callbacks: Dict[str, List[Callable]] = {}\n\n    # Configuration\n    self.state_ttl = 3600  # 1 hour default TTL\n    self.history_limit = 100  # Max history entries per state\n    self.enable_notifications = True\n\n    # Mark as initialized\n    StateManager._initialized = True\n\n    custom_log(\"\u2705 StateManager singleton initialized\")\n</code></pre>"},{"location":"reference/managers/#core.managers.state_manager.StateManager.get_instance","title":"<code>get_instance(redis_manager: Optional[RedisManager] = None, database_manager: Optional[DatabaseManager] = None) -&gt; StateManager</code>  <code>classmethod</code>","text":"<p>Get the singleton instance of StateManager.</p> <p>Parameters:</p> Name Type Description Default <code>redis_manager</code> <code>Optional[RedisManager]</code> <p>Optional Redis manager instance</p> <code>None</code> <code>database_manager</code> <code>Optional[DatabaseManager]</code> <p>Optional database manager instance</p> <code>None</code> <p>Returns:</p> Name Type Description <code>StateManager</code> <code>StateManager</code> <p>The singleton instance</p> Source code in <code>core/managers/state_manager.py</code> <pre><code>@classmethod\ndef get_instance(cls, redis_manager: Optional[RedisManager] = None, \n                database_manager: Optional[DatabaseManager] = None) -&gt; 'StateManager':\n    \"\"\"\n    Get the singleton instance of StateManager.\n\n    Args:\n        redis_manager: Optional Redis manager instance\n        database_manager: Optional database manager instance\n\n    Returns:\n        StateManager: The singleton instance\n    \"\"\"\n    return cls(redis_manager, database_manager)\n</code></pre>"},{"location":"reference/managers/#core.managers.state_manager.StateManager.reset_instance","title":"<code>reset_instance()</code>  <code>classmethod</code>","text":"<p>Reset the singleton instance (useful for testing).</p> Source code in <code>core/managers/state_manager.py</code> <pre><code>@classmethod\ndef reset_instance(cls):\n    \"\"\"Reset the singleton instance (useful for testing).\"\"\"\n    cls._instance = None\n    cls._initialized = False\n</code></pre>"},{"location":"reference/managers/#core.managers.state_manager.StateManager.register_state","title":"<code>register_state(state_id: str, state_type: StateType, initial_data: Dict[str, Any], allowed_transitions: Optional[List[str]] = None) -&gt; bool</code>","text":"<p>Register a new state in the system.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>str</code> <p>Unique identifier for the state</p> required <code>state_type</code> <code>StateType</code> <p>Type of state (system, user, session, etc.)</p> required <code>initial_data</code> <code>Dict[str, Any]</code> <p>Initial state data</p> required <code>allowed_transitions</code> <code>Optional[List[str]]</code> <p>List of allowed transition types</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registration successful</p> Source code in <code>core/managers/state_manager.py</code> <pre><code>def register_state(self, state_id: str, state_type: StateType, \n                  initial_data: Dict[str, Any], \n                  allowed_transitions: Optional[List[str]] = None) -&gt; bool:\n    \"\"\"\n    Register a new state in the system.\n\n    Args:\n        state_id: Unique identifier for the state\n        state_type: Type of state (system, user, session, etc.)\n        initial_data: Initial state data\n        allowed_transitions: List of allowed transition types\n\n    Returns:\n        bool: True if registration successful\n    \"\"\"\n    try:\n        if state_id in self._states:\n            self.logger.warning(f\"State {state_id} already exists, updating instead\")\n            return self.update_state(state_id, initial_data)\n\n        # Create state record\n        state_record = {\n            'id': state_id,\n            'type': state_type.value,\n            'data': initial_data,\n            'created_at': datetime.utcnow().isoformat(),\n            'updated_at': datetime.utcnow().isoformat(),\n            'version': 1,\n            'active': True\n        }\n\n        # Store in memory\n        self._states[state_id] = state_record\n\n        # Store in Redis for persistence\n        self._store_state_in_redis(state_id, state_record)\n\n        # Store in database for long-term persistence\n        self._store_state_in_database(state_id, state_record)\n\n        # Initialize history\n        self._state_history[state_id] = []\n        self._add_to_history(state_id, StateTransition.CREATE.value, initial_data)\n\n        # Set transition rules\n        if allowed_transitions:\n            self._transition_rules[state_id] = {\n                'allowed': allowed_transitions,\n                'current': StateTransition.CREATE.value\n            }\n\n        custom_log(f\"\u2705 State {state_id} registered successfully\")\n        return True\n\n    except Exception as e:\n        self.logger.error(f\"Failed to register state {state_id}: {e}\")\n        return False\n</code></pre>"},{"location":"reference/managers/#core.managers.state_manager.StateManager.get_state","title":"<code>get_state(state_id: str) -&gt; Optional[Dict[str, Any]]</code>","text":"<p>Retrieve a state by ID.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>str</code> <p>State identifier</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Dict containing state data or None if not found</p> Source code in <code>core/managers/state_manager.py</code> <pre><code>def get_state(self, state_id: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve a state by ID.\n\n    Args:\n        state_id: State identifier\n\n    Returns:\n        Dict containing state data or None if not found\n    \"\"\"\n    try:\n        # Try memory first\n        if state_id in self._states:\n            return self._states[state_id]\n\n        # Try Redis\n        redis_state = self._get_state_from_redis(state_id)\n        if redis_state:\n            self._states[state_id] = redis_state\n            return redis_state\n\n        # Try database\n        db_state = self._get_state_from_database(state_id)\n        if db_state:\n            self._states[state_id] = db_state\n            # Cache in Redis\n            self._store_state_in_redis(state_id, db_state)\n            return db_state\n\n        return None\n\n    except Exception as e:\n        self.logger.error(f\"Failed to get state {state_id}: {e}\")\n        return None\n</code></pre>"},{"location":"reference/managers/#core.managers.state_manager.StateManager.update_state","title":"<code>update_state(state_id: str, new_data: Dict[str, Any], transition: Optional[StateTransition] = None) -&gt; bool</code>","text":"<p>Update an existing state.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>str</code> <p>State identifier</p> required <code>new_data</code> <code>Dict[str, Any]</code> <p>New state data</p> required <code>transition</code> <code>Optional[StateTransition]</code> <p>Optional transition type</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if update successful</p> Source code in <code>core/managers/state_manager.py</code> <pre><code>def update_state(self, state_id: str, new_data: Dict[str, Any], \n                transition: Optional[StateTransition] = None) -&gt; bool:\n    \"\"\"\n    Update an existing state.\n\n    Args:\n        state_id: State identifier\n        new_data: New state data\n        transition: Optional transition type\n\n    Returns:\n        bool: True if update successful\n    \"\"\"\n    try:\n        current_state = self.get_state(state_id)\n        if not current_state:\n            self.logger.error(f\"State {state_id} not found for update\")\n            return False\n\n        # Validate transition if provided\n        if transition and not self._validate_transition(state_id, transition):\n            self.logger.error(f\"Invalid transition {transition.value} for state {state_id}\")\n            return False\n\n        # Update state data\n        updated_state = current_state.copy()\n        updated_state['data'].update(new_data)\n        updated_state['updated_at'] = datetime.utcnow().isoformat()\n        updated_state['version'] += 1\n\n        # Store updated state\n        self._states[state_id] = updated_state\n        self._store_state_in_redis(state_id, updated_state)\n        self._store_state_in_database(state_id, updated_state)\n\n        # Add to history\n        transition_type = transition.value if transition else StateTransition.UPDATE.value\n        self._add_to_history(state_id, transition_type, new_data)\n\n        # Update transition rules\n        if transition:\n            self._update_transition_rules(state_id, transition)\n\n        # Trigger callbacks\n        self._trigger_state_callbacks(state_id, transition_type, new_data)\n\n        custom_log(f\"\u2705 State {state_id} updated successfully\")\n        return True\n\n    except Exception as e:\n        self.logger.error(f\"Failed to update state {state_id}: {e}\")\n        return False\n</code></pre>"},{"location":"reference/managers/#core.managers.state_manager.StateManager.delete_state","title":"<code>delete_state(state_id: str) -&gt; bool</code>","text":"<p>Delete a state from the system.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>str</code> <p>State identifier</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if deletion successful</p> Source code in <code>core/managers/state_manager.py</code> <pre><code>def delete_state(self, state_id: str) -&gt; bool:\n    \"\"\"\n    Delete a state from the system.\n\n    Args:\n        state_id: State identifier\n\n    Returns:\n        bool: True if deletion successful\n    \"\"\"\n    try:\n        if state_id not in self._states:\n            self.logger.warning(f\"State {state_id} not found for deletion\")\n            return False\n\n        # Add deletion to history before removing\n        self._add_to_history(state_id, StateTransition.DELETE.value, {})\n\n        # Remove from memory\n        del self._states[state_id]\n\n        # Remove from Redis\n        self._remove_state_from_redis(state_id)\n\n        # Mark as deleted in database (soft delete)\n        self._mark_state_deleted_in_database(state_id)\n\n        # Clean up related data\n        if state_id in self._state_history:\n            del self._state_history[state_id]\n        if state_id in self._transition_rules:\n            del self._transition_rules[state_id]\n        if state_id in self._state_callbacks:\n            del self._state_callbacks[state_id]\n\n        custom_log(f\"\u2705 State {state_id} deleted successfully\")\n        return True\n\n    except Exception as e:\n        self.logger.error(f\"Failed to delete state {state_id}: {e}\")\n        return False\n</code></pre>"},{"location":"reference/managers/#core.managers.state_manager.StateManager.get_state_history","title":"<code>get_state_history(state_id: str, limit: Optional[int] = None) -&gt; List[Dict[str, Any]]</code>","text":"<p>Get history of state changes.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>str</code> <p>State identifier</p> required <code>limit</code> <code>Optional[int]</code> <p>Maximum number of history entries to return</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of history entries</p> Source code in <code>core/managers/state_manager.py</code> <pre><code>def get_state_history(self, state_id: str, limit: Optional[int] = None) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get history of state changes.\n\n    Args:\n        state_id: State identifier\n        limit: Maximum number of history entries to return\n\n    Returns:\n        List of history entries\n    \"\"\"\n    try:\n        history = self._state_history.get(state_id, [])\n        if limit:\n            history = history[-limit:]\n        return history\n\n    except Exception as e:\n        self.logger.error(f\"Failed to get history for state {state_id}: {e}\")\n        return []\n</code></pre>"},{"location":"reference/managers/#core.managers.state_manager.StateManager.register_callback","title":"<code>register_callback(state_id: str, callback: Callable) -&gt; bool</code>","text":"<p>Register a callback function to be called when state changes.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>str</code> <p>State identifier</p> required <code>callback</code> <code>Callable</code> <p>Function to call on state change</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registration successful</p> Source code in <code>core/managers/state_manager.py</code> <pre><code>def register_callback(self, state_id: str, callback: Callable) -&gt; bool:\n    \"\"\"\n    Register a callback function to be called when state changes.\n\n    Args:\n        state_id: State identifier\n        callback: Function to call on state change\n\n    Returns:\n        bool: True if registration successful\n    \"\"\"\n    try:\n        if state_id not in self._state_callbacks:\n            self._state_callbacks[state_id] = []\n\n        self._state_callbacks[state_id].append(callback)\n        custom_log(f\"\u2705 Callback registered for state {state_id}\")\n        return True\n\n    except Exception as e:\n        self.logger.error(f\"Failed to register callback for state {state_id}: {e}\")\n        return False\n</code></pre>"},{"location":"reference/managers/#core.managers.state_manager.StateManager.get_states_by_type","title":"<code>get_states_by_type(state_type: StateType) -&gt; List[Dict[str, Any]]</code>","text":"<p>Get all states of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>state_type</code> <code>StateType</code> <p>Type of states to retrieve</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of states of the specified type</p> Source code in <code>core/managers/state_manager.py</code> <pre><code>def get_states_by_type(self, state_type: StateType) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get all states of a specific type.\n\n    Args:\n        state_type: Type of states to retrieve\n\n    Returns:\n        List of states of the specified type\n    \"\"\"\n    try:\n        states = []\n        for state_id, state_data in self._states.items():\n            if state_data.get('type') == state_type.value:\n                states.append(state_data)\n        return states\n\n    except Exception as e:\n        self.logger.error(f\"Failed to get states by type {state_type.value}: {e}\")\n        return []\n</code></pre>"},{"location":"reference/managers/#core.managers.state_manager.StateManager.get_active_states","title":"<code>get_active_states() -&gt; List[Dict[str, Any]]</code>","text":"<p>Get all active states.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of active states</p> Source code in <code>core/managers/state_manager.py</code> <pre><code>def get_active_states(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get all active states.\n\n    Returns:\n        List of active states\n    \"\"\"\n    try:\n        return [state for state in self._states.values() if state.get('active', True)]\n    except Exception as e:\n        self.logger.error(f\"Failed to get active states: {e}\")\n        return []\n</code></pre>"},{"location":"reference/managers/#core.managers.state_manager.StateManager.health_check","title":"<code>health_check() -&gt; Dict[str, Any]</code>","text":"<p>Perform health check on the state manager.</p> Source code in <code>core/managers/state_manager.py</code> <pre><code>def health_check(self) -&gt; Dict[str, Any]:\n    \"\"\"Perform health check on the state manager.\"\"\"\n    try:\n        active_states = len(self.get_active_states())\n        total_states = len(self._states)\n\n        return {\n            'status': 'healthy',\n            'active_states': active_states,\n            'total_states': total_states,\n            'redis_available': self.redis_manager.ping() if hasattr(self.redis_manager, 'ping') else True,\n            'database_available': self.database_manager.available if hasattr(self.database_manager, 'available') else True\n        }\n    except Exception as e:\n        return {\n            'status': 'unhealthy',\n            'error': str(e)\n        } \n</code></pre>"},{"location":"reference/managers/#coremanagersstate_manager","title":"core.managers.state_manager","text":"<p>File: <code>core/managers/state_manager.py</code></p> <p>Type: module</p>"},{"location":"reference/managers/#coremanagersinit","title":"core.managers.init","text":"<p>File: <code>core/managers/__init__.py</code></p> <p>Type: module</p>"},{"location":"reference/managers/#vaultmanager","title":"VaultManager","text":"<p>File: <code>core/managers/vault_manager.py</code></p> <p>Type: class</p> <p>Methods: - <code>__init__()</code> - <code>_validate_config()</code> - <code>_authenticate()</code> - <code>_ensure_authenticated()</code> - <code>get_secret()</code> - <code>get_secret_value()</code> - <code>get_mongodb_secrets()</code> - <code>get_redis_secrets()</code> - <code>get_app_secrets()</code> - <code>get_stripe_secrets()</code> - <code>get_monitoring_secrets()</code> - <code>health_check()</code> - <code>get_connection_info()</code></p> <p>Attributes: - <code>missing_vars</code> - <code>success</code> - <code>secret</code> - <code>auth_data</code> - <code>response</code> - <code>headers</code> - <code>api_path</code> - <code>response</code> - <code>response</code> - <code>auth_result</code> - <code>auth_info</code> - <code>secret_data</code> - <code>health_data</code> - <code>secrets</code></p>"},{"location":"reference/managers/#core.managers.vault_manager.VaultManager","title":"<code>core.managers.vault_manager.VaultManager</code>","text":"<p>HashiCorp Vault Manager using AppRole authentication.</p> <p>This manager handles authentication and secret retrieval from Vault using the REST API (no hvac dependency required).</p> <p>Gracefully handles missing configuration for local development.</p> Source code in <code>core/managers/vault_manager.py</code> <pre><code>class VaultManager:\n    \"\"\"\n    HashiCorp Vault Manager using AppRole authentication.\n\n    This manager handles authentication and secret retrieval from Vault\n    using the REST API (no hvac dependency required).\n\n    Gracefully handles missing configuration for local development.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the Vault manager with AppRole authentication.\"\"\"\n        self.logger = logging.getLogger(__name__)\n\n        # Vault configuration\n        self.vault_addr = os.getenv('VAULT_ADDR', 'http://vault-proxy:8200')\n        self.role_id = os.getenv('VAULT_ROLE_ID')\n        self.secret_id = os.getenv('VAULT_SECRET_ID')\n\n        # Authentication state\n        self.client_token = None\n        self.token_expiry = None\n        self.lease_duration = None\n        self.available = False  # Track if Vault is available for use\n\n        # Try to validate configuration and authenticate\n        if self._validate_config():\n            if self._authenticate():\n                self.available = True\n                self.logger.info(\"\u2705 VaultManager initialized successfully\")\n            else:\n                self.logger.warning(\"\u26a0\ufe0f VaultManager initialized but authentication failed - using file-based secrets\")\n        else:\n            self.logger.warning(\"\u26a0\ufe0f VaultManager initialized but configuration incomplete - using file-based secrets\")\n\n    def _validate_config(self) -&gt; bool:\n        \"\"\"\n        Validate Vault configuration.\n\n        Returns:\n            bool: True if configuration is valid, False otherwise\n        \"\"\"\n        missing_vars = []\n\n        if not self.role_id:\n            missing_vars.append(\"VAULT_ROLE_ID\")\n        if not self.secret_id:\n            missing_vars.append(\"VAULT_SECRET_ID\")\n        if not self.vault_addr:\n            missing_vars.append(\"VAULT_ADDR\")\n\n        if missing_vars:\n            self.logger.warning(f\"\u26a0\ufe0f Missing Vault environment variables: {', '.join(missing_vars)}\")\n            self.logger.warning(\"\u26a0\ufe0f VaultManager will be unavailable - falling back to file-based secrets\")\n            return False\n\n        self.logger.info(f\"\u2705 Vault configuration validated: {self.vault_addr}\")\n        return True\n\n    def _authenticate(self) -&gt; bool:\n        \"\"\"\n        Authenticate with Vault using AppRole.\n\n        Returns:\n            bool: True if authentication successful, False otherwise\n        \"\"\"\n        try:\n            auth_data = {\n                'role_id': self.role_id,\n                'secret_id': self.secret_id\n            }\n\n            response = requests.post(\n                f'{self.vault_addr}/v1/auth/approle/login',\n                json=auth_data,\n                timeout=10\n            )\n\n            if response.status_code == 200:\n                auth_result = response.json()\n                auth_info = auth_result.get('auth', {})\n\n                self.client_token = auth_info.get('client_token')\n                self.lease_duration = auth_info.get('lease_duration', 3600)\n\n                # Set token expiry (with 5 minute buffer)\n                self.token_expiry = datetime.now() + timedelta(seconds=self.lease_duration - 300)\n\n                self.logger.info(f\"\u2705 Vault authentication successful (lease: {self.lease_duration}s)\")\n                return True\n            else:\n                self.logger.warning(f\"\u26a0\ufe0f Vault authentication failed: {response.status_code} - {response.text}\")\n                return False\n\n        except requests.exceptions.RequestException as e:\n            self.logger.warning(f\"\u26a0\ufe0f Vault authentication request failed: {e}\")\n            return False\n        except Exception as e:\n            self.logger.warning(f\"\u26a0\ufe0f Vault authentication error: {e}\")\n            return False\n\n    def _ensure_authenticated(self) -&gt; bool:\n        \"\"\"\n        Ensure we have a valid authentication token.\n\n        Returns:\n            bool: True if authenticated, False otherwise\n        \"\"\"\n        if not self.available:\n            return False\n\n        # Check if token exists and is not expired\n        if (self.client_token and \n            self.token_expiry and \n            datetime.now() &lt; self.token_expiry):\n            return True\n\n        # Re-authenticate if token is missing or expired\n        self.logger.info(\"Token expired or missing, re-authenticating...\")\n        success = self._authenticate()\n        if not success:\n            self.available = False\n            self.logger.warning(\"\u26a0\ufe0f Vault re-authentication failed - marking as unavailable\")\n        return success\n\n    def get_secret(self, path: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieve a secret from Vault.\n\n        Args:\n            path (str): Secret path (e.g., 'flask-app/mongodb')\n\n        Returns:\n            Optional[Dict[str, Any]]: Secret data or None if not found or Vault unavailable\n        \"\"\"\n        if not self.available:\n            return None\n\n        if not self._ensure_authenticated():\n            self.logger.warning(\"\u26a0\ufe0f Cannot retrieve secret: authentication failed\")\n            return None\n\n        try:\n            headers = {\n                'X-Vault-Token': self.client_token\n            }\n\n            # Use KV v2 API format\n            api_path = f'/v1/secret/data/{path}'\n            response = requests.get(\n                f'{self.vault_addr}{api_path}',\n                headers=headers,\n                timeout=10\n            )\n\n            if response.status_code == 200:\n                secret_data = response.json()\n                # KV v2 stores data in data.data\n                if 'data' in secret_data and 'data' in secret_data['data']:\n                    secrets = secret_data['data']['data']\n                    self.logger.info(f\"\u2705 Retrieved secret from path: {path}\")\n                    return secrets\n                else:\n                    self.logger.warning(f\"\u26a0\ufe0f No data found in secret path: {path}\")\n                    return None\n            elif response.status_code == 404:\n                self.logger.warning(f\"\u26a0\ufe0f Secret not found: {path}\")\n                return None\n            else:\n                self.logger.warning(f\"\u26a0\ufe0f Failed to retrieve secret {path}: {response.status_code}\")\n                return None\n\n        except requests.exceptions.RequestException as e:\n            self.logger.warning(f\"\u26a0\ufe0f Request failed for secret {path}: {e}\")\n            return None\n        except Exception as e:\n            self.logger.warning(f\"\u26a0\ufe0f Error retrieving secret {path}: {e}\")\n            return None\n\n    def get_secret_value(self, path: str, key: str, default: Any = None) -&gt; Any:\n        \"\"\"\n        Get a specific value from a secret.\n\n        Args:\n            path (str): Secret path\n            key (str): Key within the secret\n            default (Any): Default value if key not found\n\n        Returns:\n            Any: Secret value or default\n        \"\"\"\n        if not self.available:\n            return default\n\n        secret = self.get_secret(path)\n        if secret and key in secret:\n            return secret[key]\n        return default\n\n    def get_mongodb_secrets(self) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get MongoDB secrets from Vault.\"\"\"\n        if not self.available:\n            return None\n        return self.get_secret('flask-app/mongodb')\n\n    def get_redis_secrets(self) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get Redis secrets from Vault.\"\"\"\n        if not self.available:\n            return None\n        return self.get_secret('flask-app/redis')\n\n    def get_app_secrets(self) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get Flask application secrets from Vault.\"\"\"\n        if not self.available:\n            return None\n        return self.get_secret('flask-app/app')\n\n    def get_stripe_secrets(self) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get Stripe secrets from Vault.\"\"\"\n        if not self.available:\n            return None\n        return self.get_secret('flask-app/stripe')\n\n    def get_monitoring_secrets(self) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get monitoring secrets from Vault.\"\"\"\n        if not self.available:\n            return None\n        return self.get_secret('flask-app/monitoring')\n\n    def health_check(self) -&gt; bool:\n        \"\"\"\n        Check Vault health and connectivity.\n\n        Returns:\n            bool: True if Vault is healthy, False otherwise\n        \"\"\"\n        if not self.available:\n            return False\n\n        try:\n            response = requests.get(\n                f'{self.vault_addr}/v1/sys/health',\n                timeout=10\n            )\n\n            if response.status_code == 200:\n                health_data = response.json()\n                if health_data.get('sealed', True):\n                    self.logger.warning(\"\u26a0\ufe0f Vault is sealed\")\n                    return False\n                else:\n                    self.logger.info(\"\u2705 Vault health check passed\")\n                    return True\n            else:\n                self.logger.warning(f\"\u26a0\ufe0f Vault health check failed: {response.status_code}\")\n                return False\n\n        except requests.exceptions.RequestException as e:\n            self.logger.warning(f\"\u26a0\ufe0f Vault health check request failed: {e}\")\n            return False\n        except Exception as e:\n            self.logger.warning(f\"\u26a0\ufe0f Vault health check error: {e}\")\n            return False\n\n    def get_connection_info(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get Vault connection information for debugging.\n\n        Returns:\n            Dict[str, Any]: Connection information\n        \"\"\"\n        return {\n            'vault_addr': self.vault_addr,\n            'available': self.available,\n            'authenticated': self.client_token is not None,\n            'token_expiry': self.token_expiry.isoformat() if self.token_expiry else None,\n            'lease_duration': self.lease_duration,\n            'role_id': self.role_id[:15] + '...' if self.role_id else None\n        } \n</code></pre>"},{"location":"reference/managers/#core.managers.vault_manager.VaultManager-functions","title":"Functions","text":""},{"location":"reference/managers/#core.managers.vault_manager.VaultManager.__init__","title":"<code>__init__()</code>","text":"Source code in <code>core/managers/vault_manager.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the Vault manager with AppRole authentication.\"\"\"\n    self.logger = logging.getLogger(__name__)\n\n    # Vault configuration\n    self.vault_addr = os.getenv('VAULT_ADDR', 'http://vault-proxy:8200')\n    self.role_id = os.getenv('VAULT_ROLE_ID')\n    self.secret_id = os.getenv('VAULT_SECRET_ID')\n\n    # Authentication state\n    self.client_token = None\n    self.token_expiry = None\n    self.lease_duration = None\n    self.available = False  # Track if Vault is available for use\n\n    # Try to validate configuration and authenticate\n    if self._validate_config():\n        if self._authenticate():\n            self.available = True\n            self.logger.info(\"\u2705 VaultManager initialized successfully\")\n        else:\n            self.logger.warning(\"\u26a0\ufe0f VaultManager initialized but authentication failed - using file-based secrets\")\n    else:\n        self.logger.warning(\"\u26a0\ufe0f VaultManager initialized but configuration incomplete - using file-based secrets\")\n</code></pre>"},{"location":"reference/managers/#core.managers.vault_manager.VaultManager.get_secret","title":"<code>get_secret(path: str) -&gt; Optional[Dict[str, Any]]</code>","text":"<p>Retrieve a secret from Vault.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Secret path (e.g., 'flask-app/mongodb')</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Optional[Dict[str, Any]]: Secret data or None if not found or Vault unavailable</p> Source code in <code>core/managers/vault_manager.py</code> <pre><code>def get_secret(self, path: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve a secret from Vault.\n\n    Args:\n        path (str): Secret path (e.g., 'flask-app/mongodb')\n\n    Returns:\n        Optional[Dict[str, Any]]: Secret data or None if not found or Vault unavailable\n    \"\"\"\n    if not self.available:\n        return None\n\n    if not self._ensure_authenticated():\n        self.logger.warning(\"\u26a0\ufe0f Cannot retrieve secret: authentication failed\")\n        return None\n\n    try:\n        headers = {\n            'X-Vault-Token': self.client_token\n        }\n\n        # Use KV v2 API format\n        api_path = f'/v1/secret/data/{path}'\n        response = requests.get(\n            f'{self.vault_addr}{api_path}',\n            headers=headers,\n            timeout=10\n        )\n\n        if response.status_code == 200:\n            secret_data = response.json()\n            # KV v2 stores data in data.data\n            if 'data' in secret_data and 'data' in secret_data['data']:\n                secrets = secret_data['data']['data']\n                self.logger.info(f\"\u2705 Retrieved secret from path: {path}\")\n                return secrets\n            else:\n                self.logger.warning(f\"\u26a0\ufe0f No data found in secret path: {path}\")\n                return None\n        elif response.status_code == 404:\n            self.logger.warning(f\"\u26a0\ufe0f Secret not found: {path}\")\n            return None\n        else:\n            self.logger.warning(f\"\u26a0\ufe0f Failed to retrieve secret {path}: {response.status_code}\")\n            return None\n\n    except requests.exceptions.RequestException as e:\n        self.logger.warning(f\"\u26a0\ufe0f Request failed for secret {path}: {e}\")\n        return None\n    except Exception as e:\n        self.logger.warning(f\"\u26a0\ufe0f Error retrieving secret {path}: {e}\")\n        return None\n</code></pre>"},{"location":"reference/managers/#core.managers.vault_manager.VaultManager.get_secret_value","title":"<code>get_secret_value(path: str, key: str, default: Any = None) -&gt; Any</code>","text":"<p>Get a specific value from a secret.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Secret path</p> required <code>key</code> <code>str</code> <p>Key within the secret</p> required <code>default</code> <code>Any</code> <p>Default value if key not found</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Secret value or default</p> Source code in <code>core/managers/vault_manager.py</code> <pre><code>def get_secret_value(self, path: str, key: str, default: Any = None) -&gt; Any:\n    \"\"\"\n    Get a specific value from a secret.\n\n    Args:\n        path (str): Secret path\n        key (str): Key within the secret\n        default (Any): Default value if key not found\n\n    Returns:\n        Any: Secret value or default\n    \"\"\"\n    if not self.available:\n        return default\n\n    secret = self.get_secret(path)\n    if secret and key in secret:\n        return secret[key]\n    return default\n</code></pre>"},{"location":"reference/managers/#core.managers.vault_manager.VaultManager.get_mongodb_secrets","title":"<code>get_mongodb_secrets() -&gt; Optional[Dict[str, Any]]</code>","text":"<p>Get MongoDB secrets from Vault.</p> Source code in <code>core/managers/vault_manager.py</code> <pre><code>def get_mongodb_secrets(self) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Get MongoDB secrets from Vault.\"\"\"\n    if not self.available:\n        return None\n    return self.get_secret('flask-app/mongodb')\n</code></pre>"},{"location":"reference/managers/#core.managers.vault_manager.VaultManager.get_redis_secrets","title":"<code>get_redis_secrets() -&gt; Optional[Dict[str, Any]]</code>","text":"<p>Get Redis secrets from Vault.</p> Source code in <code>core/managers/vault_manager.py</code> <pre><code>def get_redis_secrets(self) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Get Redis secrets from Vault.\"\"\"\n    if not self.available:\n        return None\n    return self.get_secret('flask-app/redis')\n</code></pre>"},{"location":"reference/managers/#core.managers.vault_manager.VaultManager.get_app_secrets","title":"<code>get_app_secrets() -&gt; Optional[Dict[str, Any]]</code>","text":"<p>Get Flask application secrets from Vault.</p> Source code in <code>core/managers/vault_manager.py</code> <pre><code>def get_app_secrets(self) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Get Flask application secrets from Vault.\"\"\"\n    if not self.available:\n        return None\n    return self.get_secret('flask-app/app')\n</code></pre>"},{"location":"reference/managers/#core.managers.vault_manager.VaultManager.get_stripe_secrets","title":"<code>get_stripe_secrets() -&gt; Optional[Dict[str, Any]]</code>","text":"<p>Get Stripe secrets from Vault.</p> Source code in <code>core/managers/vault_manager.py</code> <pre><code>def get_stripe_secrets(self) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Get Stripe secrets from Vault.\"\"\"\n    if not self.available:\n        return None\n    return self.get_secret('flask-app/stripe')\n</code></pre>"},{"location":"reference/managers/#core.managers.vault_manager.VaultManager.get_monitoring_secrets","title":"<code>get_monitoring_secrets() -&gt; Optional[Dict[str, Any]]</code>","text":"<p>Get monitoring secrets from Vault.</p> Source code in <code>core/managers/vault_manager.py</code> <pre><code>def get_monitoring_secrets(self) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Get monitoring secrets from Vault.\"\"\"\n    if not self.available:\n        return None\n    return self.get_secret('flask-app/monitoring')\n</code></pre>"},{"location":"reference/managers/#core.managers.vault_manager.VaultManager.health_check","title":"<code>health_check() -&gt; bool</code>","text":"<p>Check Vault health and connectivity.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if Vault is healthy, False otherwise</p> Source code in <code>core/managers/vault_manager.py</code> <pre><code>def health_check(self) -&gt; bool:\n    \"\"\"\n    Check Vault health and connectivity.\n\n    Returns:\n        bool: True if Vault is healthy, False otherwise\n    \"\"\"\n    if not self.available:\n        return False\n\n    try:\n        response = requests.get(\n            f'{self.vault_addr}/v1/sys/health',\n            timeout=10\n        )\n\n        if response.status_code == 200:\n            health_data = response.json()\n            if health_data.get('sealed', True):\n                self.logger.warning(\"\u26a0\ufe0f Vault is sealed\")\n                return False\n            else:\n                self.logger.info(\"\u2705 Vault health check passed\")\n                return True\n        else:\n            self.logger.warning(f\"\u26a0\ufe0f Vault health check failed: {response.status_code}\")\n            return False\n\n    except requests.exceptions.RequestException as e:\n        self.logger.warning(f\"\u26a0\ufe0f Vault health check request failed: {e}\")\n        return False\n    except Exception as e:\n        self.logger.warning(f\"\u26a0\ufe0f Vault health check error: {e}\")\n        return False\n</code></pre>"},{"location":"reference/managers/#core.managers.vault_manager.VaultManager.get_connection_info","title":"<code>get_connection_info() -&gt; Dict[str, Any]</code>","text":"<p>Get Vault connection information for debugging.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Connection information</p> Source code in <code>core/managers/vault_manager.py</code> <pre><code>def get_connection_info(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get Vault connection information for debugging.\n\n    Returns:\n        Dict[str, Any]: Connection information\n    \"\"\"\n    return {\n        'vault_addr': self.vault_addr,\n        'available': self.available,\n        'authenticated': self.client_token is not None,\n        'token_expiry': self.token_expiry.isoformat() if self.token_expiry else None,\n        'lease_duration': self.lease_duration,\n        'role_id': self.role_id[:15] + '...' if self.role_id else None\n    } \n</code></pre>"},{"location":"reference/managers/#coremanagersvault_manager","title":"core.managers.vault_manager","text":"<p>File: <code>core/managers/vault_manager.py</code></p> <p>Type: module</p>"},{"location":"reference/managers/#coremanagerssecret_manager","title":"core.managers.secret_manager","text":"<p>File: <code>core/managers/secret_manager.py</code></p> <p>Type: module</p>"},{"location":"reference/managers/#encryptionmanager","title":"EncryptionManager","text":"<p>File: <code>core/managers/encryption_manager.py</code></p> <p>Type: class</p> <p>Methods: - <code>__init__()</code> - <code>_initialize_fernet()</code> - <code>encrypt_data()</code> - <code>decrypt_data()</code> - <code>encrypt_sensitive_fields()</code> - <code>decrypt_sensitive_fields()</code></p> <p>Attributes: - <code>SALT_LENGTH</code> - <code>ITERATIONS</code> - <code>key</code> - <code>kdf</code> - <code>derived_key</code> - <code>encrypted_data</code> - <code>encrypted_data</code> - <code>decrypted_data</code> - <code>data</code> - <code>decrypted_data</code></p>"},{"location":"reference/managers/#core.managers.encryption_manager.EncryptionManager","title":"<code>core.managers.encryption_manager.EncryptionManager</code>","text":"<p>Manager for handling data encryption at rest.</p> Source code in <code>core/managers/encryption_manager.py</code> <pre><code>class EncryptionManager:\n    \"\"\"Manager for handling data encryption at rest.\"\"\"\n\n    # Encryption key derivation settings\n    SALT_LENGTH = 16\n    ITERATIONS = 100000\n\n    def __init__(self):\n        \"\"\"Initialize the encryption manager.\"\"\"\n        self._fernet = None\n        self._initialize_fernet()\n\n    def _initialize_fernet(self) -&gt; None:\n        \"\"\"Initialize the Fernet encryption instance.\"\"\"\n        # Use the centralized config system that handles files, environment, and Vault\n        key = Config.ENCRYPTION_KEY\n\n        if not key:\n            raise RuntimeError(\"ENCRYPTION_KEY is required - check Vault, secret files, or environment variables\")\n\n        # Derive encryption key using PBKDF2\n        kdf = PBKDF2HMAC(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=Config.ENCRYPTION_SALT.encode(),\n            iterations=self.ITERATIONS\n        )\n        derived_key = base64.urlsafe_b64encode(kdf.derive(key.encode()))\n\n        # Initialize Fernet with derived key\n        self._fernet = Fernet(derived_key)\n\n    def encrypt_data(self, data: Any) -&gt; str:\n        \"\"\"\n        Encrypt data using AES-256.\n\n        Args:\n            data: Data to encrypt (will be converted to string)\n\n        Returns:\n            str: Encrypted data as base64 string\n        \"\"\"\n        if not self._fernet:\n            raise RuntimeError(\"Encryption manager not initialized\")\n\n        # Convert data to string if needed\n        if not isinstance(data, str):\n            data = str(data)\n\n        # Encrypt data\n        encrypted_data = self._fernet.encrypt(data.encode())\n        return encrypted_data.decode()\n\n    def decrypt_data(self, encrypted_data: str) -&gt; str:\n        \"\"\"\n        Decrypt data that was encrypted using AES-256.\n\n        Args:\n            encrypted_data: Encrypted data as base64 string\n\n        Returns:\n            str: Decrypted data\n        \"\"\"\n        if not self._fernet:\n            raise RuntimeError(\"Encryption manager not initialized\")\n\n        # If the data is not a string, return it as-is (it's not encrypted)\n        if not isinstance(encrypted_data, str):\n            return str(encrypted_data)\n\n        # If the data doesn't look like encrypted data (not base64), return as-is\n        if not encrypted_data or len(encrypted_data) &lt; 10:\n            return encrypted_data\n\n        try:\n            # Decrypt data\n            decrypted_data = self._fernet.decrypt(encrypted_data.encode())\n            return decrypted_data.decode()\n        except Exception:\n            # If decryption fails, return the original data\n            return encrypted_data\n\n    def encrypt_sensitive_fields(self, data: Dict[str, Any], fields: list) -&gt; Dict[str, Any]:\n        \"\"\"\n        Encrypt specific fields in a dictionary.\n\n        Args:\n            data: Dictionary containing data to encrypt\n            fields: List of field names to encrypt\n\n        Returns:\n            Dict: Dictionary with encrypted fields\n        \"\"\"\n        encrypted_data = data.copy()\n        for field in fields:\n            if field in encrypted_data and encrypted_data[field] is not None:\n                encrypted_data[field] = self.encrypt_data(encrypted_data[field])\n        return encrypted_data\n\n    def decrypt_sensitive_fields(self, data: Dict[str, Any], fields: list) -&gt; Dict[str, Any]:\n        \"\"\"\n        Decrypt specific fields in a dictionary.\n\n        Args:\n            data: Dictionary containing encrypted data\n            fields: List of field names to decrypt\n\n        Returns:\n            Dict: Dictionary with decrypted fields\n        \"\"\"\n        decrypted_data = data.copy()\n        for field in fields:\n            if field in decrypted_data and decrypted_data[field] is not None:\n                decrypted_data[field] = self.decrypt_data(decrypted_data[field])\n        return decrypted_data \n</code></pre>"},{"location":"reference/managers/#core.managers.encryption_manager.EncryptionManager-functions","title":"Functions","text":""},{"location":"reference/managers/#core.managers.encryption_manager.EncryptionManager.__init__","title":"<code>__init__()</code>","text":"Source code in <code>core/managers/encryption_manager.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the encryption manager.\"\"\"\n    self._fernet = None\n    self._initialize_fernet()\n</code></pre>"},{"location":"reference/managers/#core.managers.encryption_manager.EncryptionManager.encrypt_data","title":"<code>encrypt_data(data: Any) -&gt; str</code>","text":"<p>Encrypt data using AES-256.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to encrypt (will be converted to string)</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Encrypted data as base64 string</p> Source code in <code>core/managers/encryption_manager.py</code> <pre><code>def encrypt_data(self, data: Any) -&gt; str:\n    \"\"\"\n    Encrypt data using AES-256.\n\n    Args:\n        data: Data to encrypt (will be converted to string)\n\n    Returns:\n        str: Encrypted data as base64 string\n    \"\"\"\n    if not self._fernet:\n        raise RuntimeError(\"Encryption manager not initialized\")\n\n    # Convert data to string if needed\n    if not isinstance(data, str):\n        data = str(data)\n\n    # Encrypt data\n    encrypted_data = self._fernet.encrypt(data.encode())\n    return encrypted_data.decode()\n</code></pre>"},{"location":"reference/managers/#core.managers.encryption_manager.EncryptionManager.decrypt_data","title":"<code>decrypt_data(encrypted_data: str) -&gt; str</code>","text":"<p>Decrypt data that was encrypted using AES-256.</p> <p>Parameters:</p> Name Type Description Default <code>encrypted_data</code> <code>str</code> <p>Encrypted data as base64 string</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Decrypted data</p> Source code in <code>core/managers/encryption_manager.py</code> <pre><code>def decrypt_data(self, encrypted_data: str) -&gt; str:\n    \"\"\"\n    Decrypt data that was encrypted using AES-256.\n\n    Args:\n        encrypted_data: Encrypted data as base64 string\n\n    Returns:\n        str: Decrypted data\n    \"\"\"\n    if not self._fernet:\n        raise RuntimeError(\"Encryption manager not initialized\")\n\n    # If the data is not a string, return it as-is (it's not encrypted)\n    if not isinstance(encrypted_data, str):\n        return str(encrypted_data)\n\n    # If the data doesn't look like encrypted data (not base64), return as-is\n    if not encrypted_data or len(encrypted_data) &lt; 10:\n        return encrypted_data\n\n    try:\n        # Decrypt data\n        decrypted_data = self._fernet.decrypt(encrypted_data.encode())\n        return decrypted_data.decode()\n    except Exception:\n        # If decryption fails, return the original data\n        return encrypted_data\n</code></pre>"},{"location":"reference/managers/#core.managers.encryption_manager.EncryptionManager.encrypt_sensitive_fields","title":"<code>encrypt_sensitive_fields(data: Dict[str, Any], fields: list) -&gt; Dict[str, Any]</code>","text":"<p>Encrypt specific fields in a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Dictionary containing data to encrypt</p> required <code>fields</code> <code>list</code> <p>List of field names to encrypt</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict[str, Any]</code> <p>Dictionary with encrypted fields</p> Source code in <code>core/managers/encryption_manager.py</code> <pre><code>def encrypt_sensitive_fields(self, data: Dict[str, Any], fields: list) -&gt; Dict[str, Any]:\n    \"\"\"\n    Encrypt specific fields in a dictionary.\n\n    Args:\n        data: Dictionary containing data to encrypt\n        fields: List of field names to encrypt\n\n    Returns:\n        Dict: Dictionary with encrypted fields\n    \"\"\"\n    encrypted_data = data.copy()\n    for field in fields:\n        if field in encrypted_data and encrypted_data[field] is not None:\n            encrypted_data[field] = self.encrypt_data(encrypted_data[field])\n    return encrypted_data\n</code></pre>"},{"location":"reference/managers/#core.managers.encryption_manager.EncryptionManager.decrypt_sensitive_fields","title":"<code>decrypt_sensitive_fields(data: Dict[str, Any], fields: list) -&gt; Dict[str, Any]</code>","text":"<p>Decrypt specific fields in a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Dictionary containing encrypted data</p> required <code>fields</code> <code>list</code> <p>List of field names to decrypt</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict[str, Any]</code> <p>Dictionary with decrypted fields</p> Source code in <code>core/managers/encryption_manager.py</code> <pre><code>def decrypt_sensitive_fields(self, data: Dict[str, Any], fields: list) -&gt; Dict[str, Any]:\n    \"\"\"\n    Decrypt specific fields in a dictionary.\n\n    Args:\n        data: Dictionary containing encrypted data\n        fields: List of field names to decrypt\n\n    Returns:\n        Dict: Dictionary with decrypted fields\n    \"\"\"\n    decrypted_data = data.copy()\n    for field in fields:\n        if field in decrypted_data and decrypted_data[field] is not None:\n            decrypted_data[field] = self.decrypt_data(decrypted_data[field])\n    return decrypted_data \n</code></pre>"},{"location":"reference/managers/#coremanagersencryption_manager","title":"core.managers.encryption_manager","text":"<p>File: <code>core/managers/encryption_manager.py</code></p> <p>Type: module</p>"},{"location":"reference/modules/","title":"Modules","text":"<p>Business logic modules that provide specific functionality.</p>"},{"location":"reference/modules/#init","title":"init","text":"<p>File: <code>__init__.py</code></p>"},{"location":"reference/modules/#app","title":"app","text":"<p>File: <code>app.py</code></p>"},{"location":"reference/modules/#toolsinit","title":"tools.init","text":"<p>File: <code>tools/__init__.py</code></p>"},{"location":"reference/modules/#toolsloggerinit","title":"tools.logger.init","text":"<p>File: <code>tools/logger/__init__.py</code></p>"},{"location":"reference/modules/#toolsloggeraudit_logger","title":"tools.logger.audit_logger","text":"<p>File: <code>tools/logger/audit_logger.py</code></p>"},{"location":"reference/modules/#toolserror_handlinginit","title":"tools.error_handling.init","text":"<p>File: <code>tools/error_handling/__init__.py</code></p>"},{"location":"reference/modules/#toolserror_handlingerror_handler","title":"tools.error_handling.error_handler","text":"<p>File: <code>tools/error_handling/error_handler.py</code></p>"},{"location":"reference/modules/#coremetrics","title":"core.metrics","text":"<p>File: <code>core/metrics.py</code></p>"},{"location":"reference/modules/#coreinit","title":"core.init","text":"<p>File: <code>core/__init__.py</code></p>"},{"location":"reference/modules/#coremanagershooks_manager","title":"core.managers.hooks_manager","text":"<p>File: <code>core/managers/hooks_manager.py</code></p>"},{"location":"reference/modules/#coremanagersstate_manager","title":"core.managers.state_manager","text":"<p>File: <code>core/managers/state_manager.py</code></p>"},{"location":"reference/modules/#coremanagersinit","title":"core.managers.init","text":"<p>File: <code>core/managers/__init__.py</code></p>"},{"location":"reference/modules/#coremanagersvault_manager","title":"core.managers.vault_manager","text":"<p>File: <code>core/managers/vault_manager.py</code></p>"},{"location":"reference/modules/#coremanagerssecret_manager","title":"core.managers.secret_manager","text":"<p>File: <code>core/managers/secret_manager.py</code></p>"},{"location":"reference/modules/#coremanagersencryption_manager","title":"core.managers.encryption_manager","text":"<p>File: <code>core/managers/encryption_manager.py</code></p>"},{"location":"reference/modules/#coremodulesinit","title":"core.modules.init","text":"<p>File: <code>core/modules/__init__.py</code></p>"},{"location":"reference/modules/#coremodulesbase_module","title":"core.modules.base_module","text":"<p>File: <code>core/modules/base_module.py</code></p>"},{"location":"reference/modules/#coremoduleswallet_moduleinit","title":"core.modules.wallet_module.init","text":"<p>File: <code>core/modules/wallet_module/__init__.py</code></p>"},{"location":"reference/modules/#coremodulescommunications_moduleinit","title":"core.modules.communications_module.init","text":"<p>File: <code>core/modules/communications_module/__init__.py</code></p>"},{"location":"reference/modules/#coremodulestransactions_moduleinit","title":"core.modules.transactions_module.init","text":"<p>File: <code>core/modules/transactions_module/__init__.py</code></p>"},{"location":"reference/modules/#coremodulescs_user_management_moduleinit","title":"core.modules.cs_user_management_module.init","text":"<p>File: <code>core/modules/cs_user_management_module/__init__.py</code></p>"},{"location":"reference/modules/#utilsinit","title":"utils.init","text":"<p>File: <code>utils/__init__.py</code></p>"},{"location":"reference/modules/#utilsconfiginit","title":"utils.config.init","text":"<p>File: <code>utils/config/__init__.py</code></p>"},{"location":"reference/modules/#utilsexceptionsvalidation_exceptions","title":"utils.exceptions.validation_exceptions","text":"<p>File: <code>utils/exceptions/validation_exceptions.py</code></p>"},{"location":"reference/modules/#utilsvalidationpayload_validator","title":"utils.validation.payload_validator","text":"<p>File: <code>utils/validation/payload_validator.py</code></p>"},{"location":"reference/modules/#utilsvalidationsanitizer","title":"utils.validation.sanitizer","text":"<p>File: <code>utils/validation/sanitizer.py</code></p>"},{"location":"reference/services/","title":"Services","text":"<p>Service layer components that handle external interactions.</p>"},{"location":"reference/utils/","title":"Utils &amp; Tools","text":"<p>Utility functions and tools for common operations.</p>"},{"location":"reference/utils/#toolsinit","title":"tools.init","text":"<p>File: <code>tools/__init__.py</code></p>"},{"location":"reference/utils/#toolsloggerinit","title":"tools.logger.init","text":"<p>File: <code>tools/logger/__init__.py</code></p>"},{"location":"reference/utils/#toolsloggeraudit_logger","title":"tools.logger.audit_logger","text":"<p>File: <code>tools/logger/audit_logger.py</code></p>"},{"location":"reference/utils/#toolserror_handlinginit","title":"tools.error_handling.init","text":"<p>File: <code>tools/error_handling/__init__.py</code></p>"},{"location":"reference/utils/#toolserror_handlingerror_handler","title":"tools.error_handling.error_handler","text":"<p>File: <code>tools/error_handling/error_handler.py</code></p>"},{"location":"reference/utils/#utilsinit","title":"utils.init","text":"<p>File: <code>utils/__init__.py</code></p>"},{"location":"reference/utils/#utilsconfiginit","title":"utils.config.init","text":"<p>File: <code>utils/config/__init__.py</code></p>"},{"location":"reference/utils/#utilsexceptionsvalidation_exceptions","title":"utils.exceptions.validation_exceptions","text":"<p>File: <code>utils/exceptions/validation_exceptions.py</code></p>"},{"location":"reference/utils/#utilsvalidationpayload_validator","title":"utils.validation.payload_validator","text":"<p>File: <code>utils/validation/payload_validator.py</code></p>"},{"location":"reference/utils/#utilsvalidationsanitizer","title":"utils.validation.sanitizer","text":"<p>File: <code>utils/validation/sanitizer.py</code></p>"}]}