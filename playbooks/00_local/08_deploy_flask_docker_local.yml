---
- name: Deploy Flask Application (Local minikube - Production Structure, No Vault)
  hosts: localhost
  connection: local
  vars:
    flask_namespace: flask-app
    docker_image: "flask-credit-system:latest"
  tasks:
    - name: Remove existing deployment if it exists
      shell: |
        kubectl delete deployment flask-app -n {{ flask_namespace }} --ignore-not-found=true
        kubectl delete service flask-app -n {{ flask_namespace }} --ignore-not-found=true
        kubectl delete ingress flask-app-ingress -n {{ flask_namespace }} --ignore-not-found=true
      changed_when: true
      ignore_errors: yes

    - name: Verify Docker image is available for minikube
      shell: |
        # Minikube uses Docker Desktop directly, so image is automatically available
        echo "Verifying image is available for minikube..."
        docker images | grep flask-credit-system | head -1 || echo "Image not found - will be pulled during deployment"
      changed_when: false

    - name: Verify secret exists (created earlier)
      shell: |
        kubectl get secret external -n {{ flask_namespace }}
        echo "Secret contains $(kubectl get secret external -n {{ flask_namespace }} -o jsonpath='{.data}' | jq '. | length') keys"
      changed_when: false

    - name: Create Flask Application Deployment with Production Structure
      shell: |
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: flask-app
          namespace: {{ flask_namespace }}
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: flask-app
          template:
            metadata:
              labels:
                app: flask-app
            spec:
              serviceAccountName: flask-app-sa
              containers:
              - name: flask-app
                image: {{ docker_image }}
                imagePullPolicy: Never
                ports:
                - containerPort: 5001
                env:
                # Disable Vault for local development (triggers fallback to secrets)
                - name: VAULT_ADDR
                  value: ""
                - name: VAULT_ROLE_ID
                  value: ""
                - name: VAULT_SECRET_ID
                  value: ""
                - name: FLASK_HOST
                  value: "0.0.0.0"
                - name: FLASK_PORT
                  value: "5001"
                - name: FLASK_ENV
                  value: "development"
                - name: FLASK_DEBUG
                  value: "True"
                - name: PYTHONPATH
                  value: "/app"
                # Rate Limiting Configuration
                - name: RATE_LIMIT_ENABLED
                  value: "true"
                volumeMounts:
                # Mount the 113 secret files (same as production)
                - name: secrets-volume
                  mountPath: /app/secrets
                  readOnly: true
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 5001
                  initialDelaySeconds: 30
                  periodSeconds: 10
                  timeoutSeconds: 5
                  failureThreshold: 3
                readinessProbe:
                  httpGet:
                    path: /health
                    port: 5001
                  initialDelaySeconds: 10
                  periodSeconds: 5
                  timeoutSeconds: 3
                  failureThreshold: 3
                resources:
                  requests:
                    memory: "256Mi"
                    cpu: "250m"
                  limits:
                    memory: "512Mi"
                    cpu: "500m"
                securityContext:
                  runAsNonRoot: true
                  runAsUser: 1000
                  allowPrivilegeEscalation: false
                  capabilities:
                    drop:
                      - ALL
              volumes:
              # Use the Kubernetes secret with 113 files (same as production)
              - name: secrets-volume
                secret:
                  secretName: external
        EOF
      changed_when: true

    - name: Create Flask Application Service
      shell: |
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Service
        metadata:
          name: flask-app
          namespace: {{ flask_namespace }}
        spec:
          selector:
            app: flask-app
          ports:
          - name: http
            port: 80
            targetPort: 5001
            protocol: TCP
          type: ClusterIP
        EOF
      changed_when: true

    - name: Create Ingress for Flask Application
      shell: |
        cat <<EOF | kubectl apply -f -
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: flask-app-ingress
          namespace: {{ flask_namespace }}
        spec:
          rules:
          - host: flask-app.local
            http:
              paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: flask-app
                    port:
                      number: 80
        EOF
      changed_when: true

    - name: Wait for Flask application rollout to complete
      shell: kubectl rollout status deployment/flask-app -n {{ flask_namespace }} --timeout=300s
      register: flask_rollout
      changed_when: flask_rollout.rc == 0

    - name: Wait for Flask application pod to be ready
      shell: kubectl wait --for=condition=ready pod -l app=flask-app -n {{ flask_namespace }} --timeout=300s
      register: flask_ready
      changed_when: flask_ready.rc == 0

    - name: Get Flask application status
      shell: |
        echo "=== LOCAL MINIKUBE DEPLOYMENT STATUS ==="
        kubectl get deployments -n {{ flask_namespace }} flask-app
        echo ""
        echo "=== POD STATUS ==="
        kubectl get pods -n {{ flask_namespace }} -l app=flask-app
        echo ""
        echo "=== SERVICE STATUS ==="
        kubectl get services -n {{ flask_namespace }} flask-app
        echo ""
        echo "=== RECENT LOGS ==="
        kubectl logs -n {{ flask_namespace }} deployment/flask-app --tail=20
      register: flask_status
      changed_when: false

    - name: Test Flask application health endpoint
      shell: |
        # Start port-forward in background
        kubectl port-forward -n {{ flask_namespace }} svc/flask-app 8080:80 &
        PF_PID=$!
        sleep 5
        
        # Test the health endpoint
        curl -s http://localhost:8080/health || echo "Health test failed"
        
        # Kill port-forward
        kill $PF_PID 2>/dev/null || true
      register: flask_health_test
      changed_when: false
      ignore_errors: yes

    - name: Display Flask application deployment status
      debug:
        msg: |
          üöÄ Flask Application deployed in LOCAL MINIKUBE with Production Structure!
          
          Environment: Local minikube cluster (Production structure, No Vault)
          Image: {{ docker_image }}
          Namespace: {{ flask_namespace }}
          
          Configuration:
          - Secrets: Kubernetes secret "external" (113 files, encrypted in etcd)
          - Structure: Identical to production deployment
          - Vault: Disabled (automatic fallback to K8s secrets)
          - Security: All secrets encrypted in Kubernetes etcd
          
          Application Status:
          {{ flask_status.stdout }}
          
          {% if flask_health_test.rc == 0 %}
          ‚úÖ Health check: PASSED
          {% else %}
          ‚ö†Ô∏è  Health check: FAILED (may be normal during startup)
          {% endif %}
          
          To access the application:
          1. Port forward: kubectl port-forward -n {{ flask_namespace }} svc/flask-app 8080:80
          2. Health check: http://localhost:8080/health
          3. Main app: http://localhost:8080/
          4. Direct access: http://localhost:5001 (via k3d port mapping)
          
          üöÄ Ready for development with production-identical structure!

    - name: Display final instructions
      debug:
        msg: |
          üéâ Local k3d Flask deployment completed successfully!
          
          Architecture Features:
          - üîí Kubernetes secrets (113 files, encrypted in etcd)
          - üèóÔ∏è Production-identical deployment structure
          - üîÑ Automatic Vault ‚Üí K8s secrets fallback
          - üõ°Ô∏è Same security context as production
          
          Configuration Priority (Local):
          1. ‚ùå Vault (disabled for local dev)
          2. ‚úÖ Kubernetes secret files (/app/secrets/) ‚Üê ACTIVE
          3. ‚öôÔ∏è Application defaults
          
          Development Workflow:
          1. Edit code: python_base_04_k8s/
          2. Rebuild: docker build -t flask-credit-system:latest python_base_04_k8s/
          3. Import: k3d image import flask-credit-system:latest -c local-dev
          4. Restart: kubectl rollout restart deployment/flask-app -n {{ flask_namespace }}
          
          Next steps:
          1. Deploy MongoDB: helm install mongodb bitnami/mongodb --namespace {{ flask_namespace }} --values k8s/mongodb/values.yaml
          2. Deploy Redis: helm install redis-master bitnami/redis --namespace {{ flask_namespace }} --values k8s/redis/values.yaml
          3. Monitor: kubectl logs -f -n {{ flask_namespace }} deployment/flask-app
          4. Scale: kubectl scale deployment/flask-app -n {{ flask_namespace }} --replicas=2 